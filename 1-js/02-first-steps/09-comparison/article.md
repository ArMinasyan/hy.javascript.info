# Համեմատություններ

Մենք գիտենք շատ համեմատության համար նախատեսված նշաններ մաթեմատիկայից։

JavaScript-ում դրանք գրվում են հետևյալ տեսքով․

- Մեծ/փոքր։ <code>a &gt; b</code>, <code>a &lt; b</code>։
- Մեծ/փոքր կամ հավասար։ <code>a &gt;= b</code>, <code>a &lt;= b</code>։
- Հավասար։ `a == b`, ուշադիր լինել այն բանին, որ `==` նշանով գրվածը ստուգում է հավադարությունը, մինչ դեռ `a = b` տվյալ
  տեսքով գրվածը նշանակում է վերագրում։
- Ոչ հավասար։ Մաթեմատիկայում այդ նշանը հետևյալն է <code>&ne;</code>, բայց JavaScript-ում դա ներկայացվում է հետևյալ
  տեսքով <code>a != b</code>։ Տվյալ հոդվածի վերաբերյալ, մենք կսովորենք համեմատության տարբեր տեսակների հետ, ինչպես է
  JavaScript-ը կատարում դրանք, ներադյալ կարևոր առանձնահատկությունները։

Վերջում դուք կծանոթանաք "JavaScript-ի տարօրիանկություններ"-ի հետ առնչվող խնդիրենրին։

## Արդյունքը տրամաբանական է

All comparison operators return a boolean value:
Բոլոր համեմատության գործողությունները վերադարձնում են տրամաբանական արժեք․

- `true` - նշանակում է "այո", "ճիշտ" կամ "իրական".
- `false` - նշանակում է "ոչ", "սխալ" կամ "ոչ իրական/կեղծ". Օրինակ․

```js run
alert(2 > 1);  // true (ճիշտ)
alert(2 == 1); // false (սխալ)
alert(2 != 1); // true (ճիշտ)
```

Համեմատության արդյունքը կարող է վերագրվել փոփոխականի, ինչպես ցանկացած արժեք․

```js run
let result = 5 > 4; // վերագրել համեմատության արդյունքը
alert(result); // true (ճիշտ)
```

## Խիստ համեմատություն

Եթե ցանկանում ենք ստուգել թե որ տողային փոփոխականն է մեծ, JavaScript-ը օգտագործում է այսպես կոչված "բառարան" (անգլ․՝
dictionary) կամ "բառարանային" (անգլ․՝ lexicographical) հերթականություն։ Եթե ասենք այլ կերպ, տողը համեմատվում է տառ առ
տառ։ Օրինակ․

```js run
alert('Z' > 'A'); // true
alert('Glow' > 'Glee'); // true
alert('Bee' > 'Be'); // true
```

Երկու տեսակի տողային փոփոխականների համեմատման ալգորիթմը շատ պարզ է․

1. Համեմատել երկու տողերի առաջին նշանները 2․ Եթե առաջին տողի առաջին նշանը մեծ (կամ փոքր) քան մյուս տողինը, ապա առաջին
   տողը մեծ (կամ փոքր) է քան երկրորդը
2. Հակառակ դեպքում, եթե երկու տողերի առաջին նշանները հավասար են, ապա համեմտվում է երկրորդ նշանները նույն ձևով․
3. Գործողությունը կրկնվում է մինչև երկու տողեևի ավարտը։ 5, Եթե երկու տողերը ունեն նույն երկարությունը, ապա դրանք հավասար
   են։ Հակառակ դեպքում, մեծ երկարություն ունեցող տողը ամենամեծն է

Առաջին օրինակում, `'Z' > 'A'` համեմատության արդյունքը կստացվի առաւին քայլից։

Երկրորդ համեմատությունը `'Glow'` և `'Glee'`, պահանջում է ավելի քայլեր, քանի որ տողերը համեմատվում են նիշ առ նիշ․

1. `G` նույնն է ինչ `G`։
2. `l` նույնն է ինչ `l`։
3. `o`մեծ է քան `e`։ Այստեղ համեմատթույունը վարտվում է, քանի որ առաջին տողը ավելի մեծ է, քան երկրորդը։

```smart header="Not a real dictionary, but Unicode order"
Վերևում տրված համեմատության ալգորիթմը մոտավորապես համարժեք է բառարաններում կամ հեռախոսագրքերում օգտագործվողին, բայց դա նույնը չէ:
Օրինակ։ Մեծատառ `"A"` հավասար չէ փոքրատառ `"a"`-ին։ Ո՞ր մեկն է մեծ, փոքրատառ `"a"`-ն։ Ինչու՞, քանի որ փոքրատառ նշանը ունի վաելի մեծ ինդեքս,  
այն կոդավորման աղյուսակում, որը օգտագործվում է JavaScript-ում (Unicode)։ Մենք կվերադառնանք կոնկրետ մանրամասներին և հետևանքներին, <info:string> հատվածում։
```

## Տարբեր տիպերի համեմատությունը

Երբ համեմատությունը կատարվում է տարբեր տիպերի միջև, JavaScript-ը դրանք ձևափոխում է թվի Օրինակ․

```js run
alert('2' > 1); // true, տողային '2' փոփոխականը ձևափոխվում է թվային 2-ի
alert('01' == 1); // true, տողային '01' փոփոխականը ձևափոխվում է թվային 1-ի
```

Տրամաբանական արժեքների դեպքում  `true`-ն ձևափոխվում է `1`-ի,իսկ `false`-ը `0`-ի։ Օրինակ։

```js run
alert(true == 1); // true
alert(false == 0); // true
```


Միաժամանակ հնարավոր է․
- Երկու արժեքներ նույնն են։
- Նրանցից մեկը տրամաբանական `true`-է, իսկ մյուսը տրամաբանական `false`-է։
Օրինակ․

```js run
        let a = 0;
        alert( Boolean(a) ); // false

        let b = "0";
        alert( Boolean(b) ); // true

        alert(a == b); // true!
```

JavaScript-ի տեսանկյունից, այս արդյունքը համարվում է նորմալ։ Հավասարությունը ձևափոխվում է թվային տիպի (ուստի `"0"`-ն ձևափոխվում է `0`-ի), մինչդեռ բացահայտ `Boolean`-փոխակերպումը կիրառում է մեկ այլ կանոն։


## Խիստ հավասարություն

Սովորական հավասարության ստուգումը `==` ունի խնդիր։ Դա չի կարող տարբերակել `0`-ն `false`-ից։

```js run
alert(0 == false); // true
```

Նույն բանը կատարվում է դատարկ տողային փոփոխականի հետ։

```js run
alert('' == false); // true
```

Սա պատահում է, քանի որ տարբեր տիպերի համամատման ժամանակ, այն ձևափոխվում է թվի, `==` գործողության ժամանակ։ Դատարկ տողը,
ինչպես `false`-ը, դառնում է զրո։ Ի"նչ պետք է անենք, եթե ցանկանում ենք տարբերակել `0`-ն `false`-ից։

**Խիստ համեմատույթն գործողությունը `===` ստուգում է հավասարությունը առանց տիպային կերպափոխումների**

Այլ կերպ ասած, եթե `a`-ն և `b`-ն տարբերի տիպերի են, ապա `a === b`-ն անմիջապես կվերադարձնի `false`, առանց տիպերի
կերպափոխման։

Եկեք փորձենք դա․

```js run
alert(0 === false); // false, քանի որ արժեքները ունեն տարբեր տիպեր
```

Գոյություն ունի "խիստ ոչ հավասար" գործողության նշանը `!==`, որը նման է `!=`-ին։ Խիստ հավասարության օպերատորը մի փոքր
ավելի երկար է գրվում, բայց ակնհայտ է դառնում այն, որ դա ավելի քիչ է սխալներ առաջացնում։

## Համեմատություն null և undefined-ի միջոցով

Գոյություն ունի ոչ ինտուիտիվ պահվածք, երբ `null`-ը կամ `undefined`-ը համեմատվում են այլ արժեքների հետ։ Խիստ
համեմատության `===` դեպքում․ այս արժեքները տարբեր են, քանի որ նրանցից մեկը ունի այլ տիպ

```js run
    alert(null === undefined); // false
```

Ոչ խիստ համեմատության `==` դեպքում․ Գոյություն ունի հատուկ կանոն։ Այս երկուսը համահունչ են, դրանք հավասար են իրար հետ,
բայց հավասար չեն ոչ արժեքներով։

```js run
    alert(null == undefined); // true
```

For maths and other comparisons `< > <= >=`
: `null/undefined` are converted to numbers: `null` becomes `0`, while `undefined` becomes `NaN`. Մաթեմատիկական և այլ
համեմատություններում `< > <= >=`․ `null/undefined`-ը ձևափոխվում են թվերի, `null`-ը ձևափոխվում է `0`-ի, մինչ
դեռ `undefined`-ը ձևափոխվում է `NaN`-ի։

Այժմ եկեք դիտարկենք մի քանի հետաքրքիր բաներ, որոնք տեղի են ունենում, երբ կիրառում ենք այս կանոնները: Եվ, որ ավելի կարևոր
է, ինչպես չնկնել այդ ծուղակը։

### Տարօրինակ արդյունք․ null vs 0

Եկեք համեմատենք `null`-ը զրոյի հետ․

```js run
alert(null > 0);  // (1) false
alert(null == 0); // (2) false
alert(null >= 0); // (3) *!*true*/!*
```

Մաթեմատիկորեն, դա տարօրինակ է։ Վերջին արդյունքը, որ "`null`-ը մեծ կամ հավասար է զրոի", համեմատություններից գոնե մեկը
պետք է լինի `true`, բայց երկուսնել սխալ են։ Դրա արդյունքը այն է, որ `==` և `> < >= <=` գործում են տարբեր։ Հավասարության
ստուգումը կերպափոխվում է `null`-ը թվի, այսինքն 0-ի։ Ահա թե ինչու `null >= 0`-ն ճիշտ է, իսկ `null > 0`-ը սխալ։

Մյուս կողմից, `==`-ը ստուգում է `undefined`-ը և  `null`-ը առանց ձևափոխման, դրանք հավասար են միմյանց, բայց հավասար չեն
այլ փոփոխականի, ահա թե ինչու `null == 0` արտահայտությունը համարվում է սխալ։

### Անհամեմատելի undefined-ը

`undefined` արժեքը, չի կարող համեմատվել այլ արժեքների հետ․

```js run
alert(undefined > 0); // false (1)
alert(undefined < 0); // false (2)
alert(undefined == 0); // false (3)
```

Ինչու՞ այն նման չէ այդքան զրոյին, միշտ կեղծ է Մենք ստանում ենք այս արդյունքը, քանի որ․

- Համեմատություններ `(1)`-ինը և `(2)`-րդը վերադարձնում են `false`, քան որ `undefined`-ը ձևափոխվում է `NaN`-ի, իսկ `NaN`
  -ը հատուկ թվային արժեք է, որը բոլոր համեմատությունների դեպքում վերադարձնում է `false`։
- Համեմատություն `(3)`-ը վերադարձնում է `false`, քանի որ `undefined`-ը հավասար է միայն `null`-ին և `undefined`-ին, և ոչ
  մի այլ արժեքի

### Խուսափել խնդիրներից

Ինչու՞ դիտարկեցինք այս օրինակները, պետք է անընդհատ հիշել այս առանձնահատկությունները: Դե, իրականում ոչ: Փաստորեն, այս
բարդ բաները ժամանակի ընթացքում աստիճանաբար հայտնի կդառնան, բայց այդ խնդիրներից խուսափելու հնարավոր միջոցներ կան.

- Ցանկացաց համեմատություն `undefined/null`-ով, բացի խիստ հավասարությունից, հարկավոր է հատուկ մոտեցում։
- Մի օգտագործիր `>= > < <=` համեմատությունները, այն արժեքների հետ, որոնք կարող են լինել `null/undefined`, եթե իսկապես
  վստահ չեք թե ինչ եք անում։ Եթե փոփոխականը կարող է ունենալ այս արժեքները, ստուգեք դրանք առանձին

## Ամփոփում

- Հաեմատման գործողությունները վերադարձնում են տրամաբանական արժեք
- Տողեչրը համամտվում ենտառ առ տառ, բառարանային հերթականությամբ
- Երբ տարբեր տիպեր ունեցող արժեքները համեմատվում են, դրանք ձևափոխվում են թվերի (բացառությամբ խիստ հավասարության)
- `null` և `undefined` արժեքները հավասար են `==` մեկը մյուսին և հավասար չեն մեկ այլ արժեքի
- Եղեք եղեք, երբ օգտոգործում եք համեմատություններ, ինչպիսիք են `>` կամ `<`, այն փոփոխականների հետ, ոչոնք կարող են
  պատահմամբ լինել `null/undefined`։ Լավ գաղափար է `null/undefined`-ը ստուգել առանձին։