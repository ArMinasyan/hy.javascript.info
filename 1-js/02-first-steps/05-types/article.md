# Տվյալների տիպերը

JavaScript-ում արժեքը միշտ պատկանում է տվյալների որոշակի տիպի։ Օրինակ՝ տող (string) կամ թիվ (number)։

JavaScript-ում կան տվյալների ութ հիմնական տիպեր։ Այս գլխում մենք կանրադառնանք դրանց մասնակիորեն, իսկ հաջորդ գլուխներում կխոսենք դրանցից 
յուրաքանչյուրի մասին ավելի մանրամասն։

Փոփոխականը կարող է պարունակել ցանկացած տիպի տվյալ։ Օրինակ՝ սկզբում այն կարող է պարունակել տող (string), իսկ հետո՝ փոխարինվել թվով (number)․

```js
// Սխալ չկա
let message = "բարև";
message = 123456;
```

Այն լեզուները, որոնք թույլ են տալիս նման պահվածք, կոչվում են «դինամիկ տիպավորված»։ Դա նշանակում է, որ տիպերը գոյություն ունեն, բայց 
փոփոխականները կապված չեն դրանցից ոչ մեկի հետ։

## Թիվ (Number)

```js
let n = 123;
n = 12.345;
```

*number* տիպը ներկայացնում է ինչպես ամբողջ թվերը, այնպես էլ լողացող կետով թվերը։

Թվերի համար գոյություն ունեն բազմաթիվ գործողություններ, օրինակ՝ բազմապատկում `*`, բաժանաում `/`, գումարում `+`, հանում `-` և այլն.

Բացի սովորական թվերից կան նաև այսպես կոչված «հատուկ թվային արժեքներ», որոնք նույնպես պատկանում են այս տվյալների տիպին․ `Infinity`, 
`-Infinity` 
և `NaN`։

- `Infinity`-ն ներկայացնում է մաթեմատիկական [անվերջությունը](https://en.wikipedia.org/wiki/Infinity) ∞։ Այն հատուկ արժեք է, որը մեծ է 
  ցանկացած թվից։

    Մենք կարող ենք ստանալ այն որպես զրոի վրա բաժանման արդյունք,

    ```js run
    alert( 1 / 0 ); // Infinity
    ```

    կամ վերցնելով այն ակնհայտ կերպով։

    ```js run
    alert( Infinity ); // Infinity
    ```
- `NaN`-ը նշանակում է հաշվողական սխալ։ Այն սխալ կամ անորոշ մաթեմատիկական գործողույան արդյունք է, օրինակ․

    ```js run
    alert( "ոչ թվային արժեք" / 2 ); // NaN, բաժանումը հնարավոր չէ
    ```

    `NaN`-ը անփոփոխ արժեք է։ Ցանկացած գործողություն `NaN`-ի հետ վերադարձնում է `NaN`:

    ```js run
    alert( "ոչ թվային արժեք" / 2 + 5 ); // NaN
    ```

    Եթե մաթեմատիկական արտահայտության որևէ անդամ `NaN` է, ապա ամբողջ արտահայտության արդյունքը կլինի `NaN`։

```smart header="Մաթեմատիկական գործողությունները անվտանգ են"
Մաթեմատիկական գործողությունները JavaScript-ում «անվտանգ» են։ Մենք կարող ենք կատարել ցանկացած գործողություն՝ բաժանել զրոի, ոչ թվային տողերի 
հետ վարվել ինչպես թվերի հետ։

Սկրիպտը երբեք կանգ չի առնի՝ շպրտելով սխալ։ Վատագույն դեպքում, որպես արդյունք, մենք կստանանք `NaN`։
```

Հատուկ թվային արժեքները պատկանում են «թիվ» (number) տիպին։ Իրականում դրանք թվեր չեն բառի ուղիղ իմաստով:

Թվերի հետ աշխատանքին ավելի մանրամասն կծանոթանանք <info:number> գլխում։

## BigInt

JavaScript-ում թվային (number) տիպը չի կարող ներկայացնել թվային արժեքներ, 
որոնք մեծ են <code>(2<sup>53</sup>-1)</code>-ից (նույնն է, ինչ 
`9007199254740991`), 
կամ փոքր են <code>-(2<sup>53</sup>-1)</code>-ից՝ բացասական թվերի դեպքում։ Այս տեխիկական սահմանափակումը պայմանավորված է թվերի ներքին 
ներկայացման յուրահատկություններով։

Հիմնական դեպքերում սա ավելին քան բավական է, բայց երբեմն մենք կարիք ենք ունենում օգտագործելու իսկապես մեծ թվեր, օրինակ՝ գախտնագրման կամ 
ժամանականիշի (timestamp) միկրովարկյաններով ներկայացման դեպքում։

`BigInt`-ը վերջերս ավելացվել է լեզվում՝ կամայական մեծության թվեր նեկայացնելու նպատակով։

`BigInt` արժեք ստեղծվում է թվին վերջից կցելով `n`․

```js
// «n»-ը վերջում նշանակում է, որ արժեքը BigInt տիպի է
const bigInt = 1234567890123456789012345678901234567890n;
```

Քանի որ `BigInt` թվերը հազվադեպ են օգտագործվում, դրանց այստեղ չենք անրադառնա, այլ կդիտարկենք առանձին՝ <info:bigint> գլխում։ Կարդացե՛ք այն,
եթե նման մեծ թվերի օգտագոծման կարիք կունենաք։


```smart header="Համատեղելիության խնդիրներ"
Այս պահին `BigInt`-ը համատեղելի է Firefox/Chrome/Edge/Safari զննիչների հետ, բայց ոչ IE-ի։
```

Կարող եք ստուգել [*MDN* BigInt compatibility table](https://developer.mozilla.
org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) հոդվածը, հասկանալու համար, թե զննիչների որ 
տարբերակների հետ է այն համատեղելի։

## Տող (String)

JavaScript-ում տողը պետք է շրջապատված լինի չակերտներով։

```js
let str = "Բարև";
let str2 = 'Եզակի չակերտները նույպես թույլատրելի են';
let phrase = `թեք չակերտները կարող են ներառել փոփոխականներ ${str}`;
```

JavaScript-ում գոյություն ոնեն 3 տեսակի չակերտներ.

1. Կրկնակի չակերտներ․ `"Բարև"`։
2. Եզակի չակերտներ․ `'Բարև'`։
3. Թեք չակերտներ․ <code>&#96;Բարև&#96;</code>։

Կրկնակի և միակի չակերտները «պարզ» չակերտներ են։ JavaScript-ում դրանց միջև տարբերություններ չկան։

Թեք չակերտները ունեն «ընդլայնված ֆունկցիոնալություն»։ Դրանք թույլ են տալիս ներդնել փոփոխականներ և արտահայտություններ տողի մեջ՝ դրանք 
`${…}`-ի մեջ պարփակելու միջոցով, օրինակ․

```js run
let name = "Դավիթ";

// ներդնենք փոփոխականը
alert( `Բարև, *!*${name}*/!*!` ); // Բարև, Դավիթ!

// ներդնենք արտահայտություն
alert( `արդյունքը կլինի *!*${1 + 2}*/!*` ); // արդյունքը կլինի 3
```

`${…}`-ի մեջ ներդրված արտահայտությունը գնահատվում է, և արդյունքը դառնում է տողի մի մասը։ Մենք կարող ենք տեղադրել այնեղ ամեն ինչ՝ 
փոփոխական (`name`) կամ թվաբանական արտահայտություն՝ `1 + 2`-ի նման կամ ավելի բարդ։

Ուշադրություն դարձրեք այն փաստին, որ սա հնարավոր է միյայն թեք չակերտների դեպքում։ Մյուս չակերտները չունեն այսպիսի ներդրման 
ֆունկցիոնալություն։

```js run
alert( "արդյունքը կլինի ${1 + 2}" ); // արդյունքը կլինի ${1 + 2} (կրկնակի չակերտները ոչինչ չեն անում)
```

Մենք կանրադառնանք տողերին ավելի խորացված կերպեվ <info:string> գլխում։

```smart header="Գոյություն չունի *character* տիպ։"
Որոշ լեզուներում գոյություն ունի հատուկ "character" տիպ եզակի սիմվոլների համար։ Օրինակ՝ C և Java լեզուներում այն կոչվում է «char»։

JavaScript-ում չկա նման տիպ։ Կա միայն մեկ տիպ՝ `string`։ string-ը կարող է լինել դատարկ, ունենալ մեկ կամ բազմաթիվ նիշեր։
```

## Բուլյան (տրամաբանական տիպ)

Բուլյան տիպը ունի երկու արժեք․ `true` և `false`։

Այս տիպը հիմնականում օգտագործվում է այո/ոչ արժեքներ պահելու համար․ `true` նշանակում է «այո, ճիշտ է», իսկ `false` նշանակում է «ոչ, 
սխալ է»։

Օրինակ՝

```js
let nameFieldChecked = true; // այո, անվանական դաշտը ստուգված է
let ageFieldChecked = false; // ոչ, տարիքային դաշտը ստուգված չէ
```

Բուլյան արժեքները ստացվում են նաև որպես համեմատությունների արդյունք․

```js run
let isGreater = 4 > 1;

alert( isGreater ); // true (համեմատության արդյունքն է «այո»)
```

Մենք կանրադառնանք բուլյան տիպին ավելի խորացված կերպով <info:logical-operators> գլխում։

## «null» արժեքը

`null` հատուկ արժեքը չի պատկանում վերոնշյալ տիպերից ոչ մեկին։

Այն ձևավորում է առանձին տիպ, որը պարունակում է `null` արժեքը:

```js
let age = null;
```

JavaScript-ում `null`-ը «գոյություն չունեցող օբեկտի հղում» կամ «զրոյական ցուցիչ» չէ, ինչպես որոշ այլ լեզուներում։

Այն պարզապես հատուկ արժեք է, որը նշանակում է «ոչինչ», «դատարկություն» կամ «անհայտ արժեք»։

Վերոնշյալ կոդը պնդում է, որ `age` փոփոխականի արժեքը անհայտ է։

## «undefined» արժեքը

`undefined` հատուկ արժեքը նույնպես ուրույն է։ Այն ձևավորում է իր սեփական տիպը, ճիշտ ինչպես `null`-ը։

`undefined` նշանակում է, որ «արժեք չի վերագրվել»։

Եթե փոփոխականը հայտարարված է, բայց նրան արժեք չի վերագրվել, ապա նրա արժեքը կլինի `undefined`․

```js run
let age;

alert(age); // ցույց կտա «undefined»
```

Տեխնիկապես փոփոխականին հնարավոր է ակնհայտ կերպով վերագրել `undefined` արժեքը․

```js run
let age = 100;

// արժեքը դարձնել «undefined»
age = undefined;

alert(age); // «undefined»
```

...Բայց խորհուրդ չի տրվում այդպես անել։ Սովորաբար `null`-ը օգտագործվում է փոփոխականին «դատարկ» կամ «անհայտ» արժեք վերագրելու համար, 
մինչդեռ `undefined`-ը  իրենից ենթադրում է նախնական լռելյայն արժեք՝ չվերագրված փոփոխականների համար։

## Օբյեկտներ և սիմվոլներ

`object` տիպը յուրահատուկ է։

Մնացած բոլոր տիպերը կոչվում են «պրիմիտիվ» տիպեր, քանի որ նրանց արժեքները պարզ արժեքներ են (լինի այն տող, թիվ կամ այլ արժեք)։ Օբյեկտները, 
իրենց հերթին, օգտագործվում են տվյալների համախումբ և ավելի բարդ կառուցվածքներ պահեստավորելու նպատակով։

Օբյեկտները լեզվում կարևոր տեղ են զբաղեցնում և հատուկ ուշադրության են արժանի։ Մենք կզբաղվենք դրանցով ավելի ուշ՝ <info:object> գլխում՝ 
պրիմիտիվ տիպերը ավելի խորը ուսումնասիրելուց հետո։

`symbol` տիպը օգտագործվում է օբյեկտներում չկրկնվող նույնացուցիչներ ստեղծելու համար։ Մենք այստեղ նշում ենք դրա գոյության փաստը՝ տիպերի 
նկարագիրը լիարժեք դարձնելու համար, բայց թողնում ենք դրա ուսումնասիրությունը հետագայի համար, երբ արդեն ուսումնասիրած կլինենք օբյեկտները։

## typeof օպերատորը [#type-typeof]

`typeof` օպերատորը վերադարձնում է իր արգումենտի տիպը։ Այն օգտակար է, երբ մենք ուզում ենք մշակել տարբեր տիպերի արժեքները տարբեր կերպով, կամ 
պարզեպես արագ ստուգման կարիք կա։

Այն ունի օգտագործման երկու սինտաքս․

1. Որպես օպերատոր՝ `typeof x`։
2. Որպես ֆունկցիա `typeof(x)`։

Այլ կերպ ասած, այն աշխատում է և՛ փակագծերով, և՛ առանց դրանց։ Արդյունքը նույնն է։

`typeof x`-ի կանչը վերադարձնում է տող, որը պարունակում է տիպի անվանումը․

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

Վերջին երեք տողերը ունեն հավելյալ պարզաբանման կարիք․

1. `Math`-ը ներկառուցված օբեկտ է, որը տրամադրում է մաթեմատիկական տարբեր գործողություններ և հաստատուններ։ Մենք կուսումնասիրենք այն 
   <info:number> գլխում։ Այստեղ այն պարզապես ծառայում է որպես օբյեկտի օրինակ։
2. `typeof null`-ի արդյունքը `"object"` է։ Այն `typeof` օպերատորի վարքագծի պաշտոնապես ընդունված սխալ է, որը եկել է JavaScript-ի ստեղծման 
   վաղ ժամանակներից և մնացել է լեզվում համատեղելիության նպատակով։ Անշուշտ, `null`-ը օբյեկտ չէ։ Այն հատուկ արժեք է, որը ունի իր սեփական տիպը։
3. `typeof alert`-ի արդյունքը `"function"` է, քանի որ `alert`-ը ֆունկցիա է։ Մենք կուսումնասիրենք ֆունկցիաները հաջորդ գլուխներում, որտեղ 
   կիմանանք, որ JavaScript-ը չունի առանձին «ֆունկցիա» տիպ։ Ֆունկցիաները պատկանում են օբյեկտ տիպին։ Բայց `typeof`-ը մշակում է դրանք 
   հատուկ ձևով՝ վերադարձնելով `"function"` արժեքը։ Դա նույնպես գալիս է JavaScript-ի պատմության վաղ ժամանակներից։ Տեխնիկապես վարքագիծը 
   ճիշտ չէ, բայց պրակտիկայում կարող է հարմար լինել։

## Ամփոփում

JavaScript-ում գոյություն ունեն տվյալների 8 տիպեր։

- `number` բոլոր տեսակի թվերի համար․ ամբողջ և լողացող կետով, ամբողջ թվերը սահմանափակված են <code>±(2<sup>53</sup>-1)</code> միջակայքում։
- `bigint` կամայական մեծության ամբողջ թվերի համար։
- `string` տողերի համար։ Տողը կարող է պարունակել զրո կամ ավել նիշեր, չկա նիշի համար նախատեսված առանձին տիպ։
- `boolean` `true`/`false` արժեքների համար։
- `null` անհայտ արժեքների համար․ առանձին տիպ է, որը ունի մեկ արժեք՝ `null`։
- `undefined` չվերագրված արժեքների համար․ առանձին տիպ է, որը ունի մեկ արժեք՝ `undefined`։
- `object` ավելի բարդ տվյալների կառուցվածքների համար։
- `symbol` չկրկնվող նույնացուցիչների համար։

`typeof`-ը թույլ է տալիս ստուգել, թե ինչ տիպի արժեք է պահված փոփոխականում։

- Ունի երկու ձև․ `typeof x` կամ `typeof(x)`։
- Վերադարձնում է տող, որը պարունակում է տիպի անվանումը, օրինակ՝ `"string"`։
- `null`-ի դեպքում վերադարձնում է `"object"`․ սա լեզվի սխալ է, այն իրականում օբյեկտ չէ։

Հաջորդ գլուխներում մենք կկենտրոնանանք պրիմիտիվ արժեքների վրա և երբ ծանոթանանք դրանց հետ, կանցնենք օբյեկտների ուսումնասիրությանը։
